.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "GIT-TRANSPLANT 1"
.TH GIT-TRANSPLANT 1 "2018-03-14" "git-transplant v0.04" "Git User Contributed Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SS "\s-1NAME\s0"
.IX Subsection "NAME"
git-transplant \- Copy commits to current branch replicating file state
.SS "\s-1SYNOPSIS\s0"
.IX Subsection "SYNOPSIS"
.Vb 2
\&  git transplant [<options>] <end\-point>
\&  git transplant [<options>] <base> <end\-point>
.Ve
.SS "\s-1DESCRIPTION\s0"
.IX Subsection "DESCRIPTION"
In the first form of invocation, with a single argument, that single commit is
copied to your current branch.  No merge is required, and the resulting state
(of files) on your branch is exactly the same as it was after the original
commit (\f(CW\*(C`end\-point\*(C'\fR).
.PP
In the second form of invocation, with two arguments, each commit in the range
\&\f(CW\*(C`base\*(C'\fR (exclusive) to \f(CW\*(C`end\-point\*(C'\fR (inclusive) is copied in sequence to your
current branch.
.PP
To see a log of the commits to be copied, you can preview with
.PP
.Vb 1
\&  git log \-\-topo\-order \-\-reverse \-\-oneline <base>..<end\-point>
.Ve
.PP
By default, the author date and committer date are each preserved from the
original commit.  If a date option is used, the author date and committer date
are set to the same date: the referenced date.
.PP
Since copies have new commit hashes, this constitutes rewriting history (even if
the content and metadata are identical) and so should only be done on
not-yet-published branches or where there is consensus that reference breakage
is justified.
.SS "\s-1EXAMPLES\s0"
.IX Subsection "EXAMPLES"
.Vb 4
\&  git transplant a2aa6ee f860d8f
\&  git transplant \-\-date\-from\-author a2aa6ee f860d8f
\&  git transplant \-\-date\-like\-file=Makefile f860d8f
\&  git transplant \-\-no\-commit stash@{4}
.Ve
.SS "\s-1OPTIONS\s0"
.IX Subsection "OPTIONS"
\fI\-\-author=<author string>\fR
.IX Subsection "--author=<author string>"
.PP
.Vb 2
\&  git transplant \-\-author=\*(AqNic Sandfield <nic@example.com>\*(Aq a2aa6ee f860d8f
\&  git transplant \-\-author=Nic a2aa6ee f860d8f
.Ve
.PP
Specify the author.  The full form is a string consisting of 'name <email>'.
The short form is a string to be matched against existing commits.  In pattern
matching, the first match found will be used.
.PP
\fI\-\-date=<date>\fR
.IX Subsection "--date=<date>"
.PP
.Vb 3
\&  git transplant \-\-date=\*(Aq2001\-01\-01 00:00:01\*(Aq f860d8f
\&  git transplant \-\-date=978307201 f860d8f
\&  git transplant \-\-date=\*(Aq978307201 +0100\*(Aq f860d8f
.Ve
.PP
Use the specified date.  Format can be \s-1ISO,\s0 epoch seconds, or internal (epoch +
offset).  Intended for single-commit copies.
.PP
\fI\-\-date\-from\-author\fR
.IX Subsection "--date-from-author"
.PP
.Vb 1
\&  git transplant \-\-date\-from\-author a2aa6ee f860d8f
.Ve
.PP
Use the author date of each source commit.
.PP
\fI\-\-date\-from\-committer\fR
.IX Subsection "--date-from-committer"
.PP
.Vb 1
\&  git transplant \-\-date\-from\-committer a2aa6ee f860d8f
.Ve
.PP
Use the committer date of each source commit.
.PP
\fI\-\-date\-like\-commit=<commit object>\fR
.IX Subsection "--date-like-commit=<commit object>"
.PP
.Vb 1
\&  git transplant \-\-date\-like\-commit=bb30adc f860d8f
.Ve
.PP
Use the author date of the referenced commit.  Works with a commit hash, branch,
tag, stash, etc.  Intended for single-commit copies.
.PP
\fI\-\-date\-like\-file=<file>\fR
.IX Subsection "--date-like-file=<file>"
.PP
.Vb 1
\&  git transplant \-\-date\-like\-file=Makefile f860d8f
.Ve
.PP
Use the modification time of the referenced file.  Intended for single-commit
copies.
.PP
\fI\-\-no\-commit\fR
.IX Subsection "--no-commit"
.PP
.Vb 1
\&  git transplant \-\-no\-commit f860d8f
.Ve
.PP
Copies the file content from the source commit, but does not make a new commit.
Only for single-commit copies; if a range is specified, only the first commit
will be copied.
.SS "\s-1NOTES\s0"
.IX Subsection "NOTES"
Each commit is copied as (a snapshot of) state.  So whatever files were present
at the end of the original commit, those files will be present at the end of the
new commit; files may appear as added or deleted even if those changes were not
introduced by the original commit itself (but rather one of its ancestors).
.PP
This distinction means transplant is quite specialised and distinct from
mainstream git usage.  Standard tools such as \f(CW\*(C`rebase\*(C'\fR, \f(CW\*(C`cherry\-pick\*(C'\fR, and
\&\f(CW\*(C`stash apply\*(C'\fR are focused on respecting recent history; they create a patch by
comparing the original commit with its parent(s), and a patch representing the
current branch, and then merge the two together.  Instead \f(CW\*(C`transplant\*(C'\fR
disregards recent history and copies the resulting files from the original
commit, not the changes made to those files.
.PP
The main use cases are (a) tidying up a feature branch, (b) repairing mistakes
on a branch, (c) amending the timestamps along a branch, and (d) examining the
files in old branches & stashes (avoiding merge headaches).
.PP
Examples of suitable use include:
* You want to erase one or more commits from history while preserving the
  resulting state of subsequent commits (in contrast to a rebase which would
  preserve effective changes but usually results in a different final state).
* You might want to graft a 'downstream' tree onto an 'upstream' tree in such a
  way that the earlier commits are preserved in history but their files do not
  prevail into the 'downstream' state.
* You may have used the wrong author email address.
* You want to correct mistakes in the datetime attribution.
.PP
Consider the chain of commits A..D below.
.PP
.Vb 1
\&  A\-\-\-B\-\-\-C\-\-\-D master
.Ve
.PP
From this point, the result of:
.PP
.Vb 1
\&  git checkout \-b pruned A; git transplant B D
.Ve
.PP
would be:
.PP
.Vb 3
\&    C\*(Aq\-\-D\*(Aq pruned
\&   /
\&  A\-\-\-B\-\-\-C\-\-\-D master
.Ve
.PP
This could be very useful if B accidentally introduced a secret file and C
deleted it.  However, if C did not delete it then the secret file prevails into
C and in that case the branch 'pruned' is not a fix.  (As ever with history
rewriting, the commit messages could become confusing, for instance if the
commit message in C mentions removing the problem file, but no removal is
visible in C'.  In this kind of operation it often pays to amend the commit
message at the same time.)
.PP
One advantage this tool has is it is unlikely to encounter problems, in contrast
to patch-based tools like rebase and cherry-pick which can get mired in merge
conflicts and can fail entirely.  (The comparison is moot, however, since each
side has a different goal.)
.PP
There is a common usage pattern of 'build a chain of commits, each having the
correct content' and then 'transplant the chain, giving each the correct
metadata'.
.PP
For example, consider the following sequence when a chain of commits is
discovered to have a recurring problem, such as inclusion of a private file.
.PP
.Vb 9
\&  git tag broken  # mark current branch for future reference
\&  git reset \-\-hard afc5c58  # move branch back to last \*(Aqgood\*(Aq commit
\&  git cherry\-pick \-\-no\-commit 773331a  # copy commit using rebase/cherry\-pick/transplant
\&  ...  # fix problems
\&  git commit \-C 499f61c  # reuse original message and metadata
\&  ...  # repeat from cherry\-pick if more than one broken commit
\&  git tag interim
\&  git reset \-\-hard afc5c58  # back to last \*(Aqgood\*(Aq commit
\&  git transplant \-\-date\-from\-author interim
.Ve
.PP
In the simple case of the author being wrong (eg the wrong email address), git
transplant can fix the chain in a single action via the \f(CW\*(C`\-\-author\*(C'\fR option.
.PP
\&\f(CW\*(C`git transplant\*(C'\fR can graft an entire commit chain onto the current branch, but
this needs to be done in two steps; first copy the initial (root) commit
individually, then copy the chain from there to the final commit.
.PP
.Vb 5
\&  git checkout \-\-orphan new
\&  git rm \-\-cached \-rf .
\&  git commit \-\-allow\-empty \-mInit
\&  git transplant 567f4ba  # first copy root commit individually
\&  git transplant 567f4ba master  # then copy remainder of master branch
.Ve
.SS "\s-1SUPPORT\s0"
.IX Subsection "SUPPORT"
Raise any issues discovered at the source repo:
.PP
.Vb 1
\&  https://github.com/niczero/git\-transplant/issues
.Ve
.PP
This might work on all flavours of linux, but not with ancient versions of git.
Pull requests are welcome, especially if they help with portability or
internationalisation.
.SS "PRE-CONDITIONS"
.IX Subsection "PRE-CONDITIONS"
The working directory needs to be on a branch (ie not in detached head state)
and in a clean state (ie without any pending changes).
.PP
The end-point commit needs to be reachable from the base commit (but not
necessarily from the current branch).
.SS "\s-1ERRORS AND DIAGNOSTICS\s0"
.IX Subsection "ERRORS AND DIAGNOSTICS"
A fair amount of debug data, of varying degrees of usefulness, are spat to
\&\s-1STDERR,\s0 so you might want to tee that into a file.
.PP
.Vb 1
\&  git transplant a b | tee /tmp/copy.log
.Ve
.PP
An error saying \*(L"Failed step (<that>)\*(R" means it failed when using git-reset to
mimic the resulting state of commit <that>.
.PP
An error saying \*(L"Failed patching <this> to <that>\*(R" means there was a failure
identified when comparing desired source commit <that> to latest attempt commit
<this>.  You can then use git-diff to compare those two commits.
.SS "\s-1COPYRIGHT AND LICENCE\s0"
.IX Subsection "COPYRIGHT AND LICENCE"
Copyright (c) 2017\-\-2018 Nic Sandfield.  All rights reserved.
.PP
This program is free software, you can redistribute it and/or modify it under
the terms of the \s-1MIT\s0 Licence.
